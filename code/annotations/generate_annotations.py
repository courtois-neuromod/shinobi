"""
Generate annotated event files for the Shinobi dataset from replay variables.

Requires _variables.json files generated by generate_replays.py.
Assumes a constant framerate of 60fps.
"""

import os
import os.path as op
import pandas as pd
import numpy as np
import argparse
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)
import json
import sys
sys.path.append(op.abspath(op.join(op.dirname(__file__), '../replays')))
from generate_replays import fix_position_resets

parser = argparse.ArgumentParser()
parser.add_argument(
    "-d",
    "--datapath",
    default='.',
    type=str,
    help="Data path to look for events.tsv and .bk2 files. Should be the root of the shinobi dataset.",
)



def create_runevents(runvars, events_dataframe, FS=60, get_actions=True, get_healthloss=True, get_kills=True):
    """Create a BIDS compatible events dataframe from game variables and start/duration info of repetitions

    Parameters
    ----------
    runvars : list
        A list of repvars dicts, corresponding to the different repetitions of a run. Each repvar must have it's own duration and onset.
    events_dataframe : pandas.DataFrame
        A BIDS-formatted DataFrame specifying the onset and duration of each repetition.
    FS : int
        The sampling rate of the .bk2 file
    get_actions : boolean
        If True, generates actions events based on key presses
    get_healthloss : boolean
        If True, generates health loss events based on changes on the "lives" variable
    get_kills : boolean
        If True, generates events indicating when an enemy has been killed (based on score increase)

    Returns
    -------
    events_df :
        An events DataFrame in BIDS-compatible format.
    """
    all_df = [events_dataframe]
    for idx, repvars in enumerate(runvars):
        
        repvars['rep_onset'] = [events_dataframe['onset'][idx]]
        repvars['rep_duration'] = [events_dataframe['duration'][idx]]
        rep_index = events_dataframe['rep_index'].iloc[idx]

        if "actions" in repvars.keys():
            if get_actions:
                ACTIONS = repvars["actions"]
                for act in ACTIONS:
                    temp_df = generate_key_events(repvars, act, FS=FS)
                    temp_df['onset'] = temp_df['onset'] + repvars['rep_onset']
                    temp_df['rep_index'] = rep_index
                    all_df.append(temp_df)

            if get_healthloss:
                temp_df = generate_healthloss_events(repvars, FS=FS, dur=0)
                temp_df['onset'] = temp_df['onset'] + repvars['rep_onset']
                temp_df['rep_index'] = rep_index
                all_df.append(temp_df)

            if get_kills:
                temp_df = generate_kill_events(repvars, FS=FS, dur=0)
                temp_df['onset'] = temp_df['onset'] + repvars['rep_onset']
                temp_df['rep_index'] = rep_index
                all_df.append(temp_df)

            # Level complete
            temp_df = generate_level_complete_events(repvars, FS=FS)
            if not temp_df.empty:
                temp_df['onset'] = temp_df['onset'] + repvars['rep_onset']
                temp_df['rep_index'] = rep_index
                all_df.append(temp_df)
    try:
        events_df = pd.concat(all_df).sort_values(by='onset').reset_index(drop=True)
        
        # Round onset and duration to 3 decimal places
        events_df['onset'] = events_df['onset'].round(3)
        events_df['duration'] = events_df['duration'].round(3)
        
        # Ensure integer types for frame columns and rep_index
        for col in ['frame_start', 'frame_stop', 'rep_index']:
            if col in events_df.columns:
                events_df[col] = events_df[col].astype('Int64')  # nullable integer
        
        # Reorder columns: trial_type, rep_index, level, onset, duration, frame_start, frame_stop
        cols = events_df.columns.tolist()
        priority_cols = ['trial_type', 'rep_index', 'level', 'onset', 'duration', 'frame_start', 'frame_stop']
        priority_cols = [c for c in priority_cols if c in cols]  # only include existing columns
        other_cols = [c for c in cols if c not in priority_cols]
        events_df = events_df[priority_cols + other_cols]
        
    except ValueError:
        print('No bk2 files available for this run. Returning empty df.')
        events_df = pd.DataFrame()
    return events_df


def generate_key_events(repvars, key, FS=60):
    """Create a BIDS compatible events dataframe containing key (actions) events

    Parameters
    ----------
    repvars : list
        A dict containing all the variables of a single repetition
    key : string
        Name of the action variable to process
    FS : int
        The sampling rate of the .bk2 file

    Returns
    -------
    events_df :
        An events DataFrame in BIDS-compatible format containing the
        corresponding action events.
    """
    var = np.multiply(repvars[key], 1)
    # always keep the first and last value as 0 so diff will register the state transition
    var[0] = 0
    var[-1] = 0

    var_bin = [int(val) for val in var]
    diffs = list(np.diff(var_bin, n=1))
    presses = [round(i/FS, 3) for i, x in enumerate(diffs) if x == 1]
    releases = [round(i/FS, 3) for i, x in enumerate(diffs) if x == -1]
    frame_start = [i for i, x in enumerate(diffs) if x == 1]
    frame_stop = [i for i, x in enumerate(diffs) if x == -1]
    onset = presses
    level = [repvars["level"] for x in onset]
    duration = [round(releases[i] - presses[i], 3) for i in range(len(presses))]
    trial_type = ['{}'.format(key) for i in range(len(presses))]
    events_df = pd.DataFrame(data={'onset':onset,
                                   'duration':duration,
                                   'trial_type':trial_type,
                                   'level':level,
                                   'frame_start':frame_start,
                                   'frame_stop':frame_stop})
    return events_df

def generate_kill_events(repvars, FS=60, dur=0):
    """Create a BIDS compatible events dataframe containing kill events,
    based on a sudden increase of score.
    + 200 pts : basic enemies (all levels)
    + 300 pts : mortars and machineguns (lvl 5)
    + 400 pts : cauldron-heads (level 1)
    + 500 pts : anti-riot cop (lvl 5) ; hovering ninja (lvl 4)


    Parameters
    ----------
    repvars : list
        A dict containing all the variables of a single repetition.
    FS : int
        The sampling rate of the .bk2 file
    min_dur : float
        Minimal duration of a kill segment, defaults to 1 (sec)

    Returns
    -------
    events_df :
        An events DataFrame in BIDS-compatible format containing the
        kill events.
    """
    instant_score = repvars['instantScore']
    diff_score = np.diff(instant_score, n=1)

    onset = []
    duration = []
    trial_type = []
    level = []
    frame_start = []
    frame_stop = []
    for idx, x in enumerate(diff_score):
        if x in [200,300]:
            onset.append(idx/FS)
            duration.append(dur)
            trial_type.append('Kill')
            level.append(repvars["level"])
            frame_start.append(idx)
            frame_stop.append(idx)

    #build df
    events_df = pd.DataFrame(data={'onset':onset,
                               'duration':duration,
                               'trial_type':trial_type,
                               'level':level,
                               'frame_start':frame_start,
                               'frame_stop':frame_stop})
    return events_df

def generate_healthloss_events(repvars, FS=60, dur=0):
    """Create a BIDS compatible events dataframe containing Health Loss events

    Parameters
    ----------
    repvars : dict
        A dict containing all the variables of a single repetition
    FS : int
        The sampling rate of the .bk2 file
    dur : float
        Arbitrary duration of the generated event, defaults to 0

    Returns
    -------
    events_df : pandas.DataFrame
        An events DataFrame in BIDS-compatible format containing the
        Health Loss and Gain events.
    """
    health = repvars['health']
    diff_health = np.diff(health, n=1)

    onset = []
    duration = []
    trial_type = []
    level = []
    frame_start = []
    frame_stop = []
    for idx, x in enumerate(diff_health):
        
        if x < 0:
            onset.append(idx/FS)
            duration.append(dur)
            trial_type.append('HealthLoss')
            level.append(repvars["level"])
            frame_start.append(idx)
            frame_stop.append(idx)
        if x > 0:
            onset.append(idx/FS)
            duration.append(dur)
            trial_type.append('HealthGain')
            level.append(repvars["level"])
            frame_start.append(idx)
            frame_stop.append(idx)

    events_df = pd.DataFrame(data={'onset':onset,
                               'duration':duration,
                               'trial_type':trial_type,
                               'level':level,
                               'frame_start':frame_start,
                               'frame_stop':frame_stop})
    return events_df


def generate_level_complete_events(repvars, FS=60):
    """Create a BIDS compatible events dataframe containing level complete events.

    Level completion in Shinobi is detected by a sudden increment of 5000 points
    on the instantScore variable (end-of-level bonus).

    Parameters
    ----------
    repvars : dict
        A dict containing all the variables of a single repetition.
    FS : int
        The sampling rate of the .bk2 file (default: 60)

    Returns
    -------
    events_df : pandas.DataFrame
        An events DataFrame in BIDS-compatible format containing the
        level complete event.
    """
    onset = []
    duration = []
    trial_type = []
    level = []
    frame_start = []
    frame_stop = []

    if "instantScore" not in repvars:
        return pd.DataFrame(data={
            'onset': onset,
            'duration': duration,
            'trial_type': trial_type,
            'level': level,
            'frame_start': frame_start,
            'frame_stop': frame_stop
        })

    instant_score = repvars['instantScore']
    diff_score = np.diff(instant_score, n=1)

    for idx, increment in enumerate(diff_score):
        if increment >= 5000:
            onset.append(idx / FS)
            duration.append(0)
            trial_type.append('Level_complete')
            level.append(repvars["level"])
            frame_start.append(idx)
            frame_stop.append(idx)
            break  # Only one level complete event per repetition

    events_df = pd.DataFrame(data={
        'onset': onset,
        'duration': duration,
        'trial_type': trial_type,
        'level': level,
        'frame_start': frame_start,
        'frame_stop': frame_stop
    })
    return events_df


def create_info_dict(repvars):
    info_dict = {}

    info_dict["duration"] = len(repvars["X_player"])/60

    lives_lost = sum([x for x in np.diff(repvars["lives"], n=1) if x < 0])
    if lives_lost == 0:
        cleared = True
    else:
        cleared = False
    info_dict["cleared"] = cleared

    info_dict["end_score"] = repvars["score"][-1]

    diff_health = np.diff(repvars["health"], n=1)
    try:
        index_health_loss = list(np.unique(diff_health, return_counts=True)[0]).index(-1)
        total_health_loss = np.unique(diff_health, return_counts=True)[1][index_health_loss]
    except Exception as e:
        print(e)
        total_health_loss = 0
    info_dict["total health lost"] = total_health_loss

    diff_shurikens = np.diff(repvars["shurikens"], n=1)
    try:
        index_shurikens_loss = list(np.unique(diff_shurikens, return_counts=True)[0]).index(-1)
        total_shurikens_loss = np.unique(diff_shurikens, return_counts=True)[1][index_shurikens_loss]
    except Exception as e:
        total_shurikens_loss = 0
    info_dict["shurikens used"] = total_shurikens_loss

    info_dict["enemies killed"] = len(generate_kill_events(repvars, FS=60, dur=0))
    return info_dict

def main():
    FS = 60
    
    # Get datapath
    args = parser.parse_args()
    DATA_PATH = args.datapath
    if DATA_PATH == ".":
        print("No data path specified. Searching files in this folder.")
    print(f"Generating annotations for the shinobi dataset in : {DATA_PATH}")

    # Process each file
    for root, folder, files in sorted(os.walk(DATA_PATH)):
        if not "sourcedata" in root:
            for file in files:
                if "events.tsv" in file and not "annotated" in file:
                    run_events_file = op.join(root, file)
                    events_annotated_fname = run_events_file.replace("_events.", "_desc-annotated_events.")
                    if not op.isfile(events_annotated_fname):
                        print(f"Processing : {file}")
                        events_dataframe = pd.read_table(run_events_file)
                        # Filter to keep only gym-retro_game events (explicit for robustness)
                        events_dataframe = events_dataframe[
                            events_dataframe["trial_type"] == "gym-retro_game"
                        ]
                        # Select only relevant columns and reset index to get rep_index
                        events_dataframe = events_dataframe[
                            ["trial_type", "onset", "level", "stim_file"]
                        ].reset_index()
                        events_dataframe["rep_index"] = range(1, len(events_dataframe) + 1)
                        bk2_files = events_dataframe['stim_file'].values.tolist()
                        runvars = []
                        for bk2_idx, bk2_file in enumerate(bk2_files):
                            if bk2_file != "Missing file" and type(bk2_file) != float:
                                print("Adding : " + bk2_file)
                                sub = bk2_file.split("/")[0]
                                ses = bk2_file.split("/")[1]
                                filename = bk2_file.split("/")[-1]
                                # Look for variables file in gamelogs/ within datapath
                                variables_sidecar_fname = op.join(
                                    DATA_PATH,
                                    sub,
                                    ses,
                                    "gamelogs",
                                    filename.replace(".bk2", "_variables.json"),
                                )
                                if op.exists(variables_sidecar_fname):
                                    with open(variables_sidecar_fname, "r") as f:
                                        repvars = json.load(f)
                                    
                                    # Fix position resets for X_player
                                    repvars["X_player"] = fix_position_resets(repvars["X_player"])
                                    
                                    # Add info to repetition event
                                    events_dataframe.loc[
                                        events_dataframe["stim_file"] == bk2_file,
                                        "level",
                                    ] = repvars["level"]
                                    events_dataframe.loc[
                                        events_dataframe["stim_file"] == bk2_file,
                                        "frame_start",
                                    ] = int(0)
                                    events_dataframe.loc[
                                        events_dataframe["stim_file"] == bk2_file,
                                        "frame_stop",
                                    ] = int(len(repvars["health"]))
                                    events_dataframe.loc[
                                        events_dataframe["stim_file"] == bk2_file,
                                        "duration",
                                    ] = int(len(repvars["health"])) / FS

                                    runvars.append(repvars)
                                else:
                                    print(f"\nError: Variables file not found: {variables_sidecar_fname}")
                                    print("Please run create_replays.py first to generate the required files.")
                                    return
                            else:
                                print("Missing file, skipping")
                                runvars.append({})
                        
                        events_df_annotated = create_runevents(runvars, events_dataframe)
                        
                        # Correct level naming
                        events_df_annotated.replace({'level': {'1-0': 'level-1',
                                                            '4-1': 'level-4',
                                                            '5-0': 'level-5'}}, inplace=True)
                        events_df_annotated.replace({'trial_type': {'B':'HIT',
                                                                    'C':'JUMP'}}, inplace=True)
                        # Save
                        events_df_annotated.to_csv(events_annotated_fname, sep="\t", index=False)
                        print(f"Saved annotated events to: {events_annotated_fname}")


if __name__ == "__main__":
    main()
